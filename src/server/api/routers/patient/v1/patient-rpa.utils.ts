import { AssessmentAnswer, AssessmentAnswerIntegrationStatus, Prisma } from '@prisma/client';
import { format } from 'date-fns';
import { uniqBy } from 'lodash';
import { DataRendererOptions } from '~/assessments/apricot/data-renderers/options';
import {
	getDriveEndTime,
	getDriveStartTime,
	getSocVisitEndTime,
	getVitalSignMeasurementTime,
} from '~/assessments/apricot/data-renderers/util';
import { Configuration } from '~/assessments/configurations';
import { AutoCalculateOptions } from '~/assessments/oasis/auto-calculate-fields/options';
import { AssessmentQuestionType, type AssessmentQuestion, type Group, type QuestionSource } from '~/assessments/types';
import {
	extractAllQuestionsFromGroup,
	findAllRollupGroups,
	lookupQuestion,
} from '~/assessments/util/lookupQuestionUtil';
import { resolveIdAndMultipleIndex } from '~/common/utils/resolveIdAndMultipleIndex';
import { getCanAnswer } from '~/server/api/routers/patient/patient.util';
import { RpaTRPCContext } from '~/server/rpa/trpc';
import { RpaApiContext } from '../../../../../common/types/types';
import { CheckedResponseUnion } from '../../assessment/assessment.inputs';
import { resolveConfigurationTypes } from '../../configuration/configuration.service';
import { PatientWithJoins } from '../patient.types';
import {
	autogeneratedCalculatedFields,
	getBimsAssessmentAnswers,
	getBradenRiskAssessmentAnswers,
	getFormattedHeight,
	getMAHCRiskAssessmentAnswers,
	getMoodInterviewAnswers,
	getNutritionalAssessment,
} from './calculated-fields';
import { getAssessmentCustomFormResponses, isAssessmentCustomForm } from './custom-form-responses';
import { generateWoundMappedResponse } from './rpa-wound-utils';

export type RpaAssessmentAnswer = Pick<
	AssessmentAnswer,
	'assessmentNumber' | 'checkedResponse' | 'integrationStatus' | 'integrationMessage'
>;

export type RpaAssessmentAnswerWithQuestionText = RpaAssessmentAnswer & {
	questionText: string;
	mappedType: AssessmentQuestionType | null;
};

export async function resolveAllAssessmentData(
	ctx: RpaApiContext | RpaTRPCContext,
	patient: PatientWithJoins,
	assessmentAnswers: AssessmentAnswer[],
) {
	const configuration = await ctx.db.versionedConfiguration.findFirstOrThrow({
		where: { id: patient.versionedConfigurationId },
	});
	const resolvedConfiguration = resolveConfigurationTypes(configuration);
	const completedConfig = resolvedConfiguration.backOfficeCompletedConfig;

	const extractedQuestions = completedConfig
		.flatMap((group) => extractAllQuestionsFromGroup(group, patient))
		.flatMap((item) => getAnswersForQuestionSource(item, patient, assessmentAnswers, resolvedConfiguration));

	const autogeneratedAnswers = autogeneratedCalculatedFields(assessmentAnswers);

	const autoGenerated = autogeneratedAnswers.map((item) => {
		const answer = assessmentAnswers.find((ans) => ans.assessmentNumber === item.assessmentNumber);
		if (answer) {
			return generateAnswer(
				item.assessmentNumber,
				item.questionText,
				item.checkedResponse,
				item.mappedType,
				answer.integrationStatus,
				answer.integrationMessage,
			);
		}
		return item;
	});

	const allRelevantAnswers = uniqBy(extractedQuestions.concat(autoGenerated), 'assessmentNumber');

	const addedAssessments = allRelevantAnswers.map((item) => item.assessmentNumber);
	const assessmentNotIncluded = assessmentAnswers.filter((ans) => !addedAssessments.includes(ans.assessmentNumber));

	const allOtherAnswers: RpaAssessmentAnswerWithQuestionText[] = resolvedConfiguration.allQuestions
		.filter((q) => !addedAssessments.includes(q.id))
		.filter((q) => !q.notUsed)
		.flatMap((q) => {
			const answers = findMultiIndexAssessmentAnswers(assessmentNotIncluded, q.id);
			if (!answers.length) {
				return generateAnswer(
					q.id,
					q.originalText ?? q.text,
					null,
					q.mappedType,
					AssessmentAnswerIntegrationStatus.Completed,
				);
			}
			return answers.map((answer) => ({
				assessmentNumber: answer.assessmentNumber,
				questionText: removeTypeAnnotationFromQuestionText(q.originalText ?? q.text),
				mappedType: q.mappedType,
				checkedResponse: getOriginalResponseText(answer.checkedResponse, q),
				integrationMessage: answer.integrationMessage,
				integrationStatus: answer.integrationStatus,
			}));
		});

	const { woundMappedResponses, relevantWoundAssessmentNumbers } = generateWoundMappedResponse(
		assessmentAnswers,
		resolvedConfiguration,
		patient.gender,
	);

	const allAnswers = allRelevantAnswers
		.concat(allOtherAnswers)
		.filter((item) => !relevantWoundAssessmentNumbers.includes(item.assessmentNumber))
		.concat(woundMappedResponses);

	return rollupQuestionsMarkedForRollup(completedConfig, allAnswers);
}

function removeTypeAnnotationFromQuestionText(text: string): string {
	const match = /(\s*-?\s*TYPE: .*)/;
	const didMatch = text.match(match);
	if (didMatch) {
		return text.replace(match, '').trim();
	}
	return text;
}

export function rollupQuestionsMarkedForRollup(
	backOfficeCompletedConfig: Group[],
	allQuestions: RpaAssessmentAnswerWithQuestionText[],
) {
	const rollupGroups = findAllRollupGroups(backOfficeCompletedConfig);
	const questionIdsToRemove = rollupGroups.flatMap((group) => group.questions.map((q) => q.id));
	const newRolledUpAnswers = rollupGroups.map((group) => {
		const { id, text } = group.rollupForRpaApi ?? {};
		if (!id || !text) throw new Error('Rollup group does not have an ID');
		const newCheckedResponse = group.questions.reduce((acc, question) => {
			const questionAnswer = allQuestions.find((q) => q.assessmentNumber === question.id);
			if (!questionAnswer) return acc;
			const choice = ((questionAnswer?.checkedResponse as CheckedResponseUnion)?.choice ?? '') as string;
			return acc + `${questionAnswer?.questionText}: ${choice}\n`;
		}, '');
		return generateAnswer(id, text, newCheckedResponse, AssessmentQuestionType.FreeForm);
	});
	return allQuestions.filter((q) => !questionIdsToRemove.includes(q.assessmentNumber)).concat(newRolledUpAnswers);
}

export function getGeneratedBlankAnswers() {
	const rendererFields = Object.values(DataRendererOptions).flatMap((item) => dataResolverMap[item](null, null));
	const calculatedFields = Object.values(AutoCalculateOptions).flatMap(
		(item) => autocalculatedFieldsMap[item](null, null).answers,
	);
	const autogeneratedAnswers = autogeneratedCalculatedFields([]);
	return rendererFields.concat(calculatedFields).concat(autogeneratedAnswers);
}

export function getAnswersForQuestionSource(
	questionSource: QuestionSource,
	patient: PatientWithJoins,
	assessmentAnswers: AssessmentAnswer[],
	configuration: Configuration,
): RpaAssessmentAnswerWithQuestionText | RpaAssessmentAnswerWithQuestionText[] {
	function resolveAnswers(generatedItems: RpaAssessmentAnswerWithQuestionText[] | null) {
		return (generatedItems ?? []).map((item) => {
			const dbAnswer = assessmentAnswers.find((ans) => ans.assessmentNumber === item.assessmentNumber);
			if (dbAnswer) {
				return generateAnswer(
					item.assessmentNumber,
					item.questionText,
					item.checkedResponse,
					item.mappedType ?? null,
					dbAnswer.integrationStatus,
					dbAnswer.integrationMessage,
				);
			}
			return item;
		});
	}

	if (questionSource.patientDataResolver) {
		return resolveAnswers(dataResolverMap[questionSource.patientDataResolver](patient, configuration));
	}

	if (questionSource.autoCalculateFieldResolver) {
		const { answers, followups } = autocalculatedFieldsMap[questionSource.autoCalculateFieldResolver](
			assessmentAnswers,
			configuration,
		);
		const value = resolveAnswers(answers);
		if (followups) {
			const follows = followups.flatMap((id) =>
				getAnswersForQuestionSource(
					{ id }, // assumes followup are an assessment question
					patient,
					assessmentAnswers,
					configuration,
				),
			);
			return [...value, ...follows];
		}
		return value;
	}

	if (!questionSource.id) return [];
	const lookedUp = lookupQuestion(questionSource.id, configuration);
	const assessment = assessmentAnswers.find((a) => a.assessmentNumber === questionSource.id);
	const questionText = removeTypeAnnotationFromQuestionText(lookedUp.originalText ?? lookedUp.text);

	if (!assessment) {
		const multiIndexAssessments = findMultiIndexAssessmentAnswers(assessmentAnswers, questionSource.id);
		if (multiIndexAssessments.length) {
			return multiIndexAssessments.map((ans) => {
				return generateAnswer(
					ans.assessmentNumber,
					questionText,
					getOriginalResponseText(ans.checkedResponse, lookedUp),
					lookedUp.mappedType,
					ans.integrationStatus,
					ans.integrationMessage,
				);
			});
		}
		return generateAnswer(
			lookedUp.id,
			questionText,
			null,
			lookedUp.mappedType ?? null,
			AssessmentAnswerIntegrationStatus.Completed,
		);
	}

	if (!(assessment.checkedResponse as CheckedResponseUnion)?.choice) {
		return generateAnswer(
			assessment.assessmentNumber,
			lookedUp.text,
			null,
			lookedUp.mappedType,
			assessment.integrationStatus,
			assessment.integrationMessage,
		);
	}
	if (isAssessmentCustomForm(questionSource.id)) {
		return getAssessmentCustomFormResponses(lookedUp, assessment, configuration);
	}

	return {
		assessmentNumber: lookedUp.id,
		questionText,
		mappedType: lookedUp.mappedType ?? null,
		checkedResponse: getOriginalResponseText(assessment.checkedResponse, lookedUp),
		integrationMessage: assessment.integrationMessage,
		integrationStatus: assessment.integrationStatus,
	};
}

function findMultiIndexAssessmentAnswers(assessmentAnswers: AssessmentAnswer[], questionId: string) {
	return assessmentAnswers.filter((ans) => {
		const { resolvedQuestionId } = resolveIdAndMultipleIndex(ans.assessmentNumber);
		return resolvedQuestionId === questionId;
	});
}

export function generateAnswer(
	number: string,
	text: string,
	response: AssessmentAnswer['checkedResponse'] = null,
	mappedType: AssessmentQuestionType | null,
	integrationStatus: AssessmentAnswerIntegrationStatus = AssessmentAnswerIntegrationStatus.Pending,
	integrationMessage: string | null = null,
): RpaAssessmentAnswerWithQuestionText {
	return {
		assessmentNumber: number,
		questionText: removeTypeAnnotationFromQuestionText(text),
		mappedType,
		checkedResponse:
			response && typeof response === 'object' && 'choice' in response ? response : { choice: response },
		integrationMessage,
		integrationStatus,
	};
}

export function getOriginalResponseText(
	response: Prisma.JsonValue | CheckedResponseUnion,
	question: AssessmentQuestion,
) {
	if (!response || typeof response !== 'object' || !('choice' in response)) return response;

	function getChoiceText(choice: Prisma.JsonValue) {
		if (typeof choice === 'object') return choice;
		const foundResponse = question.responses?.find(
			(r) => r.text.toLowerCase().trim() === choice.toString().toLowerCase().trim(),
		);
		const answerText = foundResponse?.originalText ?? choice;

		return answerText;
	}

	if (Array.isArray(response.choice)) {
		return { choice: response.choice.map((choice) => getChoiceText(choice)) };
	}
	if (typeof response.choice === 'string' || typeof response.choice === 'number') {
		if (question.mappedType === AssessmentQuestionType.SelectAllThatApply) {
			return { choice: [getChoiceText(response.choice)] };
		}
		return { choice: getChoiceText(response.choice) };
	}
	return response as Prisma.JsonObject;
}

/**
 * IDs starting with CUS_ are Handcoded IDs
 */

const dataResolverMap: Record<
	DataRendererOptions,
	(data: PatientWithJoins | null, configuration: Configuration | null) => RpaAssessmentAnswerWithQuestionText[]
> = {
	[DataRendererOptions.NAME]: (data) => [
		generateAnswer('M0040_A', 'First Name', data?.firstName, AssessmentQuestionType.FreeForm),
		generateAnswer('M0040_B', 'Middle Initial', data?.middleName, AssessmentQuestionType.FreeForm),
		generateAnswer('M0040_C', 'Last Name', data?.lastName, AssessmentQuestionType.FreeForm),
		generateAnswer('M0040_D', 'Suffix', data?.suffix, AssessmentQuestionType.FreeForm),
	],
	[DataRendererOptions.PATIENT_ADDRESS]: (data) => [
		generateAnswer('M0050', 'Patient State of Residence', data?.state, AssessmentQuestionType.SelectOne),
		generateAnswer('M0060', 'Zip Code', data?.zip, AssessmentQuestionType.FreeForm),
		generateAnswer(
			hardCodedIds.cust26,
			'Service Address',
			{
				address1: data?.address1,
				address2: data?.address2,
				city: data?.city,
				state: data?.state,
				county: data?.county,
				zip: data?.zip,
				notes: data?.serviceLocationNotes,
				serviceLocationType: data?.serviceLocationType,
			},
			AssessmentQuestionType.LongText,
		),
	],
	[DataRendererOptions.SOCIAL_SECURITY_NUMBER]: (data) => [
		generateAnswer(
			'M0064',
			'SSN',
			data?.socialSecurityUnknown ? 'NA' : data?.socialSecurityNumber,
			AssessmentQuestionType.FreeForm,
		),
	],
	[DataRendererOptions.PATIENT_PAYOR_DETAILS]: (data, configuration) => {
		const M0150Question = configuration?.allQuestions.find((q) => q.id === 'M0150');
		const M0150Response = M0150Question?.responses
			?.filter((r) => data?.M0150Answer.includes(r.code!))
			.map((r) => r.text);

		return [
			generateAnswer(
				'M0150',
				'(C1) (M0150) CURRENT PAYMENT SOURCES FOR HOME CARE: (MARK ALL THAT APPLY.)',
				M0150Question ? getOriginalResponseText({ choice: M0150Response ?? [] }, M0150Question) : null,
				AssessmentQuestionType.SelectAllThatApply,
			),
			generateAnswer(
				'M0063',
				'Medicare Number',
				getCanAnswer('M0063', data?.M0150Answer) ? data?.M0063Answer : 'NA',
				AssessmentQuestionType.FreeForm,
			),
			generateAnswer(
				'M0065',
				'Medicaid Number',
				getCanAnswer('M0065', data?.M0150Answer) ? data?.M0065Answer : 'NA',
				AssessmentQuestionType.FreeForm,
			),
			generateAnswer(
				'M0150_specify',
				'INDICATE OTHER FINANCIAL FACTOR(S)',
				getCanAnswer('M0150_specify', data?.M0150Answer) ? data?.M0150SpecifyAnswer : 'NA',
				AssessmentQuestionType.FreeForm,
			),
			generateAnswer(
				hardCodedIds.cust1,
				'Payor Sources',
				data?.PayorSources.map((p) => ({
					identifier: p.payorSourceIdentifier,
					name: p.payorSourceName,
					type: p.payorSourceType,
				})),
				AssessmentQuestionType.FreeForm,
			),
		];
	},

	[DataRendererOptions.GENDER]: (data) => [
		generateAnswer('M0069', 'Gender', data?.gender, AssessmentQuestionType.SelectOne),
	],
	[DataRendererOptions.DATE_OF_BIRTH]: (data) => [
		generateAnswer('M0066', 'Birth Date', data?.dateOfBirth.toISOString(), AssessmentQuestionType.Date),
	],
	[DataRendererOptions.SOC_VISIT_DATE]: (data) => [
		generateAnswer('M0030', 'SOC Visit Date', data?.SOCVisitDate?.toISOString(), AssessmentQuestionType.Date),
		generateAnswer(
			'M0090',
			'Date Assessment Completed',
			data?.SOCVisitDate?.toISOString(),
			AssessmentQuestionType.Date,
		),
	],
	[DataRendererOptions.PHYSICIAN_ORDERED_SOC_DATE]: (data) => [
		generateAnswer(
			'M0102_1',
			'(E)(M0102) IS THE DATE OF PHYSICIAN-ORDERED START OF CARE / RESUMPTION OF CARE KNOWN?',
			data?.physicianOrderedSOCDateNA ? 'NA - NO SPECIFIC SOC/ROC ORDERED BY PHYSICIAN' : '1. YES',
			AssessmentQuestionType.SelectOne,
		),
		generateAnswer(
			'M0102_2',
			'(M0102) DATE OF PHYSICIAN-ORDERED START OF CARE (RESUMPTION OF CARE): IF THE PHYSICIAN INDICATED A SPECIFIC START OF CARE (RESUMPTION OF CARE) DATE WHEN THE PATIENT WAS REFERRED FOR HOME HEALTH SERVICES, RECORD THE DATE SPECIFIED.',
			data?.physicianOrderedSOCDate?.toISOString(),
			AssessmentQuestionType.Date,
		),
	],
	[DataRendererOptions.REFERRAL_DATE]: (data) => [
		generateAnswer(
			'M0104',
			'(M0104) DATE OF REFERRAL: INDICATE THE DATE THAT THE WRITTEN OR VERBAL REFERRAL FOR INITIATION OR RESUMPTION OF CARE WAS RECEIVED BY THE HHA.',
			data?.PatientReferralSource?.referralDate?.toISOString(),
			AssessmentQuestionType.Date,
		),
	],
	[DataRendererOptions.PATIENT_ASSOCIATED_PHYSICIANS]: (data) => [
		generateAnswer(
			hardCodedIds.cust2,
			'Associated Providers',
			data?.PatientAssociatedPhysicians.map((p, index) => ({
				primaryProvider: index === 0,
				name: p.name,
				type: p.providerType,
				notes: p.notes,
				phone: p.phone,
				referringPhysician: p.referringPhysician,
			})),
			AssessmentQuestionType.LongText,
		),
	],
	[DataRendererOptions.PATIENT_REFERRAL_SOURCE]: (data) => [
		generateAnswer(
			hardCodedIds.cust3,
			'Patient Referral Source',
			data?.PatientReferralSource
				? {
						contactName: data.PatientReferralSource.contactName,
						contactPhone: data.PatientReferralSource.contactPhone,
						facilityName: data.PatientReferralSource.facilityName,
						facilityType: data.PatientReferralSource.facilityType,
					}
				: null,
			AssessmentQuestionType.LongText,
		),
	],
	[DataRendererOptions.PATIENT_CASE_MANAGER]: (data) => [
		generateAnswer(
			hardCodedIds.cust4,
			'Case Manager',
			data?.SOCVisitCaseManager
				? {
						id: data.SOCVisitCaseManager?.id,
						name: data.SOCVisitCaseManager?.name,
					}
				: null,
			AssessmentQuestionType.LongText,
		),
	],
	[DataRendererOptions.PATIENT_PHONE_NUMBER]: (data) => [
		generateAnswer(hardCodedIds.cust5, 'Patient Phone Number', data?.phoneNumber, AssessmentQuestionType.FreeForm),
		generateAnswer(
			hardCodedIds.cust24,
			'Patient Mobile Phone Number',
			data?.mobilePhoneNumber,
			AssessmentQuestionType.FreeForm,
		),
		generateAnswer(
			hardCodedIds.cust25,
			'Patient Alternate Phone Number',
			data?.alternatePhoneNumber,
			AssessmentQuestionType.FreeForm,
		),
	],
	// empty since we are including them in above resolver
	[DataRendererOptions.PATIENT_MOBILE_PHONE_NUMBER]: () => [],
	[DataRendererOptions.PATIENT_ALTERNATE_PHONE_NUMBER]: () => [],
	[DataRendererOptions.PATIENT_EMERGENCY_CONTACTS]: (data) => [
		generateAnswer(
			hardCodedIds.cust6,
			'Contacts',
			data?.PatientEmergencyContacts.map((p) => ({
				firstName: p.firstName,
				lastName: p.lastName,
				type: p.type,
				relationship: p.relationship,
				primaryPhone: p.phone,
				homePhone: p.homePhone,
				alternatePhone: p.alternatePhone,
				mobilePhone: p.mobilePhone,
				address: p.address,
				city: p.city,
				state: p.state,
				zip: p.zip,
				comments: p.notes,
				availability: p.availability,
			})),

			AssessmentQuestionType.LongText,
		),
	],
	[DataRendererOptions.SOC_VISIT_START_TIME]: (data) => [
		generateAnswer(
			'AC1',
			'SOC Visit Start Time',
			data?.SOCVisitTime ? format(data.SOCVisitTime, 'HH:mm') : null,
			AssessmentQuestionType.FreeForm,
		),
	],
	[DataRendererOptions.TIME_IN_HOME]: (data) => [
		generateAnswer(
			hardCodedIds.cust8,
			'Minutes Spent with Patient',
			data?.NurseInterview?.minutesSpentWithPatient,
			AssessmentQuestionType.FreeForm,
		),
	],
	[DataRendererOptions.DRIVE_TIME]: (data) => [
		generateAnswer(
			hardCodedIds.cust9,
			'Drive time',
			data?.NurseInterview?.minutesSpentDriving ?? null,
			AssessmentQuestionType.FreeForm,
		),
	],
	[DataRendererOptions.MILEAGE]: (data) => [
		generateAnswer(
			hardCodedIds.cust10,
			'Mileage',
			data?.NurseInterview?.distanceTraveled,
			AssessmentQuestionType.FreeForm,
		),
	],
	[DataRendererOptions.BRANCH]: (data) => [
		generateAnswer(hardCodedIds.cust11, 'Branch', data?.Location?.name, AssessmentQuestionType.FreeForm),
	],
	[DataRendererOptions.DRIVE_START_TIME]: (data) => [
		generateAnswer(
			hardCodedIds.cust20,
			'Drive Start Time',
			data ? getDriveStartTime(data)?.toISOString() ?? null : null,
			AssessmentQuestionType.FreeForm,
		),
	],
	[DataRendererOptions.DRIVE_END_TIME]: (data) => [
		generateAnswer(
			hardCodedIds.cust21,
			'Drive End Time',
			data ? getDriveEndTime(data)?.toISOString() ?? null : null,
			AssessmentQuestionType.FreeForm,
		),
	],
	[DataRendererOptions.SOC_VISIT_END_TIME]: (data) => [
		generateAnswer(
			hardCodedIds.cust22,
			'SOC Visit End Time',
			data ? getSocVisitEndTime(data)?.toISOString() ?? null : null,
			AssessmentQuestionType.FreeForm,
		),
	],
	[DataRendererOptions.VITAL_SIGNS_MEASUREMENT_TIME]: (data) => [
		generateAnswer(
			hardCodedIds.cust23,
			'Vital Sign Measurement time',
			data ? getVitalSignMeasurementTime(data)?.toISOString() ?? null : null,
			AssessmentQuestionType.FreeForm,
		),
		wipHardCodedVitalException(hardCodedIds.AC1040_Exception, 'Comments on height exception'),
		wipHardCodedVitalException(hardCodedIds.AC1045_Exception, 'Comments on weight exception'),
		wipHardCodedVitalException(hardCodedIds.AC1050_Exception, 'Comments on temperature exception'),
		wipHardCodedVitalException(hardCodedIds.AC1060_Exception, 'Comments on pulse exception'),
		wipHardCodedVitalException(hardCodedIds.AC1070_Exception, 'Comments on respirations exception'),
		wipHardCodedVitalException(hardCodedIds.AC1080_Exception, 'Comments on systolic BP exception'),
		wipHardCodedVitalException(hardCodedIds.AC1083_Exception, 'Comments on diastolic BP exception'),
		wipHardCodedVitalException(hardCodedIds.AC1091_Exception, 'Comments on oxygen saturation exception'),
		wipHardCodedVitalException(hardCodedIds.AC1101_Exception, 'Comments on pain level exception'),
		wipHardCodedVitalException(hardCodedIds.AC1111_Exception, 'Comments on blood sugar exception'),
		wipHardCodedVitalException(hardCodedIds.AC1121_Exception, 'Comments on INR level exception'),
		wipHardCodedVitalException(hardCodedIds.AC1131_Exception, 'Comments on prothrombin time exception'),
		wipHardCodedVitalException(hardCodedIds.AC1141_Exception, 'Comments on ankle circumference exception'),
		wipHardCodedVitalException(hardCodedIds.AC1151_Exception, 'Comments on calf circumference exception'),
		wipHardCodedVitalException(hardCodedIds.AC1161_Exception, 'Comments on girth exception'),
		wipHardCodedVitalException(hardCodedIds.AC1171_Exception, 'Comments on head circumference exception'),
		wipHardCodedVitalException(hardCodedIds.AC1181_Exception, 'Comments on instep circumference exception'),
		wipHardCodedVitalException(hardCodedIds.AC1191_Exception, 'Comments on thigh circumference exception'),
		generateAnswer(
			hardCodedIds.cust12,
			"Was the patient's physician notified about medication interactions?",
			'YES',
			AssessmentQuestionType.SelectOne,
		),
		generateAnswer(
			hardCodedIds.cust18,
			"Was the patient's physician notified about vital sign exceptions?",
			'YES',
			AssessmentQuestionType.SelectOne,
		),
	],
};

const autocalculatedFieldsMap: Record<
	AutoCalculateOptions,
	(
		answers: AssessmentAnswer[] | null,
		configuration: Configuration | null,
	) => { answers: RpaAssessmentAnswerWithQuestionText[]; followups?: string[] }
> = {
	[AutoCalculateOptions.BIMS_ASSESSMENT]: getBimsAssessmentAnswers,
	[AutoCalculateOptions.BRADEN_RISK_ASSESSMENT]: getBradenRiskAssessmentAnswers,
	[AutoCalculateOptions.NUTRITIONAL_ASSESSMENT]: getNutritionalAssessment,
	[AutoCalculateOptions.MAHC_RISK_ASSESSMENT]: getMAHCRiskAssessmentAnswers,
	[AutoCalculateOptions.MOOD_INTERVIEW]: getMoodInterviewAnswers,
	[AutoCalculateOptions.PATIENT_FORMATTED_HEIGHT]: getFormattedHeight,
};

export const hardCodedIds = {
	cust1: customId('01'),
	cust2: customId('02'),
	cust3: customId('03'),
	cust4: customId('04'),
	cust5: customId('05'),
	cust6: customId('06'),
	cust8: customId('08'),
	cust9: customId('09'),
	cust10: customId('10'),
	cust11: customId('11'),
	cust12: customId('12'),
	cust13: customId('13'),
	cust14: customId('14'),
	cust15: customId('15'),
	cust16: customId('16'),
	cust17: customId('17'),
	cust18: customId('18'),
	cust19: customId('19'),
	cust20: customId('20'),
	cust21: customId('21'),
	cust22: customId('22'),
	cust23: customId('23'),
	cust24: customId('024'),
	cust25: customId('025'),
	cust26: customId('26'),

	AC1040_Exception: 'AC1040_exception_comment',
	AC1045_Exception: 'AC1045_exception_comment',
	AC1050_Exception: 'AC1050_exception_comment',
	AC1060_Exception: 'AC1060_exception_comment',
	AC1070_Exception: 'AC1070_exception_comment',
	AC1080_Exception: 'AC1080_exception_comment',
	AC1083_Exception: 'AC1083_exception_comment',
	AC1091_Exception: 'AC1091_exception_comment',
	AC1101_Exception: 'AC1101_exception_comment',
	AC1111_Exception: 'AC1111_exception_comment',
	AC1121_Exception: 'AC1121_exception_comment',
	AC1131_Exception: 'AC1131_exception_comment',
	AC1141_Exception: 'AC1141_exception_comment',
	AC1151_Exception: 'AC1151_exception_comment',
	AC1161_Exception: 'AC1161_exception_comment',
	AC1171_Exception: 'AC1171_exception_comment',
	AC1181_Exception: 'AC1181_exception_comment',
	AC1191_Exception: 'AC1191_exception_comment',
};

function customId(num: string) {
	return `CUS${num}`;
}

function wipHardCodedVitalException(id: string, text: string) {
	return generateAnswer(id, text, 'test exception notes', AssessmentQuestionType.FreeForm);
}
